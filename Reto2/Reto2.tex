\documentclass{article}
\usepackage{multirow}
\usepackage[spanish]{babel}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts,dsfont}
\usepackage{enumitem}
\usepackage[margin=1in]{geometry}

% Para el código, por si queremos al menos mencionar una posible implementación del tipo de dato
\usepackage{listings}
\usepackage{xcolor}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\newcommand{\n}[1]{{\color{gray}#1}}
\lstset{numbers=left,numberstyle=\small\color{gray}}

\newcommand{\algorithm}[4]{
	\fbox{\parbox{14cm}{
		\textbf {\Large Algoritmo #1:} \\
		\textbf {Entrada:} #2 \\
		\textbf {Salida:} #3 \\
		\textbf {Procedimiento:} \\
		#4
	}}
}
\newcommand{\cifrasalg}[2]{
	\algorithm{#1}{$C = \{c_1, c_2, c_3, c_4, c_5, c_6\}$, $T \in [100, 999)$}{$L$ y $N$ tales que el valor de $N$ se acerca todo lo posible a $T$ y puede construirse la serie de operaciones con el algoritmo de obtención de operaciones}{#2}
}

\title{Reto 2}
\date{Estructura de Datos}
\author{Pablo Baeyens Fernández\\José Manuel Muñoz Fuentes\\Darío Sierra Martínez}

\begin{document}
\maketitle

\section{Introducción}
En este reto se pide un algoritmo que, a partir de un conjunto $C$ de seis números enteros que
pertenezcan al conjunto $C_T = \{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 25, 50, 75, 100\}$ (no necesariamente distintos entre sí)
y un entero $S \in [100, 1000)$ llamado solución, devuelva una lista de
operaciones básicas (suma, resta, producto, división exacta) que, estando
efectuadas sobre elementos del conjunto $C$ y sobre números obtenidos con
operaciones previas, permitan obtener un valor tan cercano a $S$ como sea
posible, usando cada elemento de $C$ y cada número obtenido durante el proceso como máximo una vez. \\

Buscaremos, por consiguiente, un algoritmo que trate de obtener la solución
exacta siempre que sea posible, o en su defecto el valor más cercano a la solución que
pueda obtenerse.

\section{Algoritmo}
El algoritmo propuesto tiene como objetivo construir todos los caminos posibles que pueden seguirse usando los números de $C$ y las operaciones disponibles. Para ello, tomará $L$ como la lista que se
identifica con el conjunto $C$, y ampliará $L$ con listas de cuatro elementos
$[n, i, j, op]$, donde $n$ es un entero obtenido a partir de los elementos que ocupan
las posiciones $i$ y $j$ en $L$ mediante la operación $op$.\\

En primer lugar, se observa que, para cada par de números, solo hay una suma y un producto posibles (porque tales operaciones son conmutativas), y solo hay como máximo una resta y un cociente que den resultados válidos y distintos ($a-b > 0 \implies b - a < 0$, mientras que $a/b \ge 1 \implies b/a = a/b$ o $b/a \notin \mathds N$). Así, a la hora de recorrer $L$ para obtener nuevos elementos, solo tendremos que comprobar cada par de elementos una vez para hacer la operación de cada tipo que puede hacerse con ellos, y no dos veces. En el caso de la resta, tomaremos la diferencia del mayor menos el menos; y para el cociente, también haremos el del mayor entre el menor. Si el menor fuese $0$ o la división no fuese exacta, definiremos el resultado de la división como $0$. Se verá la utilidad de esto a la hora de filtrar elementos, más adelante. \\

Por comodidad,
definiremos $L_i$ como el $i$-ésimo elemento de $L$, y ``el valor de $L_i$'' como el primer elemento de $L_i$ si $L_i$ es lista o como $L_i$ si es
un entero. Esta estructura de $L$ nos permitirá, una vez hallemos la solución o
un resultado lo más cercano posible a la misma, obtener la secuencia de pasos,
mediante el siguiente procedimiento recursivo: \\

\algorithm{de obtención de operaciones}
{$L$ y $N$, con $N = [n, i, j, op]$ o $N = n$}
{La serie de operaciones con elementos de $L$ con la que se ha llegado a $n$}{
	Si $N$ no es solo un número $n$:
	\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item Aplicar este mismo algoritmo con entrada $L$, $L_i$
	\item Aplicar este mismo algoritmo con entrada $L$, $L_j$
	\item Si $op$ no es una operación conmutativa (es decir, es resta o cociente)
	y el valor de $L_i$ es menor que el de $L_j$, intercambiar $i$ y $j$
	\item Devolver la concatenación de lo obtenido en los dos primeros puntos
	junto con \texttt{a operador b = n}, con $a$ el valor de $L_i$ y $b$
	el valor de $L_j$
	\end{itemize}
}\\

Además se necesitan más definiciones:\\
\emph{Nota: en esta sección se definen funciones para poder describir el algoritmo. Estas funciones no tienen por qué existir en un hipotético programa que ponga en práctica este algoritmo. De hecho, ofrecería un mejor resultado introducir los valores que toman estas funciones para cada $L_i$ como un elemento más en la lista que lo constituye.}
\begin{itemize}
	\item Sea $L_k$ un elemento de $L$, se dirá que $gen(L_k) = 1$, o que $L_k$ es de ``primera generación'' si $k \le 6$ (es decir, $L_k$ es uno de de los seis números que procedían de $C$), y se dirá que $gen(L_k) = n$, o que $L_k$ es de ``$n$-ésima generación'' si la suma de las generaciones de los elementos de los que procede (es decir, $gen(L_{L_k.i}) + gen(L_{L_k.j}) = n$). El algoritmo se ejecutará de forma que, en cada iteración, se obtendrán elementos que serán exclusivamente de una generación en particular, controlando la generación de los dos elementos de los que procede cada uno.
	
	\item Definiremos la función $miembros(i)$ como el conjunto de los elementos de $L$ cuya generación es $i$, es decir, los $\{L_k : gen(k) = i\}$. Esto nos permitirá diferenciar los elementos de $L$ según en qué momento de la ejecución del algoritmo han sido obtenidos y determinar el inicio y el final de los bucles que recorren los elementos con los que se operará en cada paso.

	\item Se define el conjunto de ``números usados por $L_k$'', expresado $U(L_k)$, como $\{L_k\}$ si $k \le 6$ (es decir, si $L_k$ se corresponde con alguno de los seis números de $C$), y como $A \cup B$ si $A =U(L_{L_k.i})$ y $B = U(L_{L_k.j})$. De esta forma, $U(L_k)$ representa el conjunto de números de $C$ que han intervenido para obtener $L_k$. Esto será crucial para poder comprobar a cada paso del algoritmo si es posible operar con dos elementos entre sí: para ello, la intersección de los números usados por cada uno debe ser vacía para proceder (porque, evidentemente, no puede usarse un elemento inicial más de una vez, y operar con dos elementos que hayan usado un mismo elemento equivaldría a usar un elemento inicial más de una vez).
	
\end{itemize}

Por otro lado, para reducir el número de elementos de $L$ se tendrá en cuenta las siguientes observaciones. Sea $a\ op\ b = c$ uno de los pasos realizadas en una solución (el orden de $a$ y $b$ es relevante: $L$ se recorre de forma que la posición de $a$ siempre es anterior a la de $b$), obteniendo $c$ a partir de la operación $op$ con $a$ y $b$:

\begin{itemize}
	\item Si una operación realizada cumple que $c=a$, existe otra solución que omite ese paso y simplemente usa $a$ en lugar de $c$, y lo mismo ocurre si $c=b$. Por ello, no se añadirá un elemento a $L$ si surge de una operación que da un resultado que coincida con el de uno de los elementos de los que se obtuvo.
	\item Si en una operación realizada cumple que $c < 0$, debe descartarse la operación y no añadirse el elemento porque está prohibido emplear elementos temporales negativos.
	\item Si en una operación realizada cumple que $c = 0$, existe otra solución que no emplea esta operación (puesto que con un $0$ temporal solo puede obtenerse otro $0$ o un valor igual a otro número disponible, o en caso de división indica una operación inválida). Por ello, se descartará la operación en tal caso. Aquí es donde se aprovecha la redefinición de la división: como hemos determinado que si la división $a/b$ no es exacta o $b=0$ el resultado es $0$, esto hará que se descarte la operación en esos casos.
	\item Si $a$ surgió a partir de la misma operación $op$ que se está realizando (es decir, $d\ op\ e = a,\ a\ op\ b = c$, y por tanto $(d\ op\ e)\ op\ b = c$), existe otra solución que no emplea esta operación (y por tanto puede descartarse esta operación), porque:
	\begin{itemize}
		\item Si $op$ es conmutativa (es suma o producto), la expresión $(d\ op\ e)\ op\ b = c$ equivale a $d\ op\ (e\ op\ b) = c$. Se hará esta segunda en su lugar.
		\item Si $op$ no es conmutativa (es resta o división) y es válida (es decir, en caso de división es exacta), la expresión $(d\ op\ e)\ op\ b = c$ equivale a $d\ op\ (e\ op_{inv}\ b) = c$, siendo $op_{inv}$ la operación opuesta (si $op$ es resta, la suma; si $op$ es división, el producto). Se hará esta segunda en su lugar.
	\end{itemize}
	\item Si $b$ surgió a partir de la misma operación $op$ que se está realizando (es decir, $d\ op\ e = b,\ a\ op\ b = c$, y por tanto $a\ op\ (d\ op\ e) = c$), en algunos casos (pero no todos) también es posible descartar la operación; a saber:
	\begin{itemize}
		\item Si $op$ no es conmutativa y es válida (no se llega a un resultado negativo al restar ni a un cociente no exacto al dividir), la expresión $a\ op\ (d\ op\ e)\ = c$ equivale a $(a\ op_{inv}\ e)\ op\ d\ = c$. Se hará esta segunda en su lugar.
		\item Si $op$ sí es conmutativa, y además la posición de $d$ en $L$ es anterior a la posición de $a$, la expresión $a\ op\ (d\ op\ e)\ = c$ equivale a $d\ op\ (a\ op\ e)\ = c$. Se hará esta segunda en su lugar.
	\end{itemize}
\end{itemize}

Diremos que una lista $[n, i, j, op]$ es ``válida'' si no puede ser eliminada por todo lo expuesto. De esta forma, eliminaremos múltiples caminos que serían redundantes.\\

Se almacenará a cada elemento añadido el que más se aproxime a la solución en $N$. Cuando termine el algoritmo, se consultará $N$ y se generarán las operaciones realizadas con el algoritmo anterior. \\

El algoritmo que se propone, con los bucles expresados aprovechando las funciones definidas (después se repetirá con el inicio y final de los bucles expresados explícitamente), devolverá un $L$ y $N$ con los que se podrá construir, con el algoritmo anterior, una solución que se acerque lo más posible al objetivo:\\

\cifrasalg{de obtención de solución}{Sea $L$ la lista que se corresponde con $C$ ($L = [c_1, c_2, c_3, c_4, c_5, c_6]$), y sea $N$ un elemento cualquiera (se modificará durante el algoritmo) de $L$.\\
Para $g = 2$ hasta $6$:\\
%		Para $i = 1$ hasta $G_{((g+1)/2+1)}-1$:\\
Para cada $i$ tal que $2 \cdot gen(L_i) \le g$:\\
Para cada $j \in miembros(g-gen(L_i)))$ tal que $j > i$:\\
Si $U(L_i) \cap  U(L_j) = \emptyset$:\\
Para cada $op$ operación:\\
Si $[n, i, j, op]$, con $n = L_i.n\ op\ L_j.n$, es ``válido'':
\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item Añadir $[n, i, j, op]$ a $L$
	\item Si $|n-T| < |N.n-T|$:
	\begin{itemize}
		\item $N.n \leftarrow [n, i, j, op]$
		\item Si $N = T$, FIN: devuelve $L, N$
	\end{itemize}
\end{itemize}
FIN: devuelve $L, N$
	%Intentar tabular la anidación de bucles o algo, que queda feísimo como está ahora.
}

\vspace{0.4cm}

Para poder definir con exactitud el inicio y el final de los bucles que recorren los elementos de $L$, se empleará una lista $G$ de seis elementos, que indicará en la posición $G_i$ el primer elemento de $L$ que es de $i$-ésima generación. Esto permitirá establecer el inicio y el final de cada bucle. Definiremos también $G_7$ como la posición siguiente a la del último elemento de $L$. La función $miembros(i)$ podría redefinirse aprovechando $G$ como $\{L_k : k \ge G_i, k < G_{i+1}\}$.


\subsection{Características del algoritmo}

\section{El tipo de dato}

\section{Combinaciones mágicas}
\subsection{Algoritmo para buscar combinaciones mágicas}

\end{document}
